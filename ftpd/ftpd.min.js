/* eslint-disable */
module.exports = function(modules) { var installedModules = {};

    function __webpack_require__(moduleId) { if (installedModules[moduleId]) { return installedModules[moduleId].exports } var module = installedModules[moduleId] = { i: moduleId, l: false, exports: {} };
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        module.l = true; return module.exports }
    __webpack_require__.m = modules;
    __webpack_require__.c = installedModules;
    __webpack_require__.d = function(exports, name, getter) { if (!__webpack_require__.o(exports, name)) { Object.defineProperty(exports, name, { configurable: false, enumerable: true, get: getter }) } };
    __webpack_require__.n = function(module) { var getter = module && module.__esModule ? function getDefault() { return module["default"] } : function getModuleExports() { return module };
        __webpack_require__.d(getter, "a", getter); return getter };
    __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property) };
    __webpack_require__.p = ""; return __webpack_require__(__webpack_require__.s = 1) }([function(module, exports) { module.exports = require("path") }, function(module, exports, __webpack_require__) { var net = __webpack_require__(2); var util = __webpack_require__(3); var events = __webpack_require__(4); var pathModule = __webpack_require__(0); var fsModule = __webpack_require__(5); var StatMode = __webpack_require__(6); var dateformat = __webpack_require__(7); var glob = __webpack_require__(8); var starttls = __webpack_require__(9); var LOG_ERROR = 0; var LOG_WARN = 1; var LOG_INFO = 2; var LOG_DEBUG = 3; var LOG_TRACE = 4;
    exports.LOG_LEVELS = { LOG_ERROR: LOG_ERROR, LOG_WARN: LOG_WARN, LOG_INFO: LOG_INFO, LOG_DEBUG: LOG_DEBUG, LOG_TRACE: LOG_TRACE }; var EventEmitter = events.EventEmitter;

    function pathEscape(text) { text = text.replace(/"/g, '""'); return text }

    function withCwd(cwd, path) { var firstChar = (path || "").charAt(0);
        cwd = cwd || pathModule.sep;
        path = path || ""; if (firstChar === "/" || firstChar === pathModule.sep) { cwd = pathModule.sep }
        path = pathModule.join(pathModule.sep, cwd, path); return path }

    function stripOptions(str) { var IN_SPACE = 0; var IN_DASH = 1; var state = IN_SPACE; for (var i = 0; i < str.length; ++i) { var c = str.charAt(i); if (state === IN_SPACE) { if (c === " " || c === "\t") {} else if (c === "-") { state = IN_DASH } else { return str.substr(i) } } else if (state === IN_DASH && (c === " " || c === "\t")) { state = IN_SPACE } } return "" }

    function PassiveListener() { EventEmitter.call(this) }
    util.inherits(PassiveListener, EventEmitter);

    function FtpServer(host, options) { var self = this;
        EventEmitter.call(self);
        self.host = host;
        self.options = options; if (!self.options.maxStatsAtOnce) { self.options.maxStatsAtOnce = 5 } if (!options.getInitialCwd) { throw new Error("'getInitialCwd' option of FtpServer must be set") } if (!options.getRoot) { throw new Error("'getRoot' option of FtpServer must be set") }
        self.getInitialCwd = options.getInitialCwd;
        self.getRoot = options.getRoot;
        self.getUsernameFromUid = options.getUsernameFromUid || function(uid, c) { c(null, "ftp") };
        self.getGroupFromGid = options.getGroupFromGid || function(gid, c) { c(null, "ftp") };
        self.debugging = options.logLevel || 0;
        self.useWriteFile = options.useWriteFile;
        self.useReadFile = options.useReadFile;
        self.uploadMaxSlurpSize = options.uploadMaxSlurpSize || 0;
        self.server = net.createServer();
        self.server.on("connection", function(socket) { self._onConnection(socket) });
        self.server.on("error", function(err) { self.emit("error", err) });
        self.server.on("close", function() { self.emit("close") }) }
    util.inherits(FtpServer, EventEmitter);
    FtpServer.prototype._onConnection = function(socket) { var allowedCommands = null; if (this.options.allowedCommands) { allowedCommands = {};
            this.options.allowedCommands.forEach(function(c) { allowedCommands[c.trim().toUpperCase()] = true }) } var conn = new FtpConnection({ server: this, socket: socket, pasv: null, allowedCommands: allowedCommands, dataPort: 20, dataHost: null, dataListener: null, dataSocket: null, dataConfigured: false, mode: "ascii", filefrom: "", username: null, filename: "", fs: null, cwd: null, root: null, hasQuit: false, secure: false, pbszReceived: false });
        this.emit("client:connected", conn);
        socket.setTimeout(0);
        socket.setNoDelay();
        this._logIf(LOG_INFO, "Accepted a new client connection");
        conn.respond("220 FTP server (nodeftpd) ready");
        socket.on("data", function(buf) { conn._onData(buf) });
        socket.on("end", function() { conn._onEnd() });
        socket.on("error", function(err) { conn._onError(err) });
        socket.on("close", function(hadError) { conn._onClose(hadError) }) };
    ["listen", "close"].forEach(function(fname) { FtpServer.prototype[fname] = function() { return this.server[fname].apply(this.server, arguments) } });
    FtpServer.prototype._logIf = function(verbosity, message, conn) { if (verbosity > this.debugging) { return } var peerAddr = conn && conn.socket && conn.socket.remoteAddress; if (peerAddr) { message = "<" + peerAddr + "> " + message } if (verbosity === LOG_ERROR) { message = "ERROR: " + message } else if (verbosity === LOG_WARN) { message = "WARNING: " + message }
        console.log(message); var isError = verbosity === LOG_ERROR; if (isError && this.debugging === LOG_TRACE) { console.trace("Trace follows") } };

    function FtpConnection(properties) { EventEmitter.call(this); var self = this;
        Object.keys(properties).forEach(function(key) { self[key] = properties[key] }) }
    util.inherits(FtpConnection, EventEmitter);
    FtpConnection.prototype.respond = function(message, callback) { return this._writeText(this.socket, message + "\r\n", callback) };
    FtpConnection.prototype._logIf = function(verbosity, message) { return this.server._logIf(verbosity, message, this) };
    FtpConnection.prototype._writeText = function(socket, data, callback) { if (!socket.writable) { this._logIf(LOG_DEBUG, "Attempted writing to a closed socket:\n>> " + data.trim()); return }
        this._logIf(LOG_TRACE, ">> " + data.trim()); return socket.write(data, "utf8", callback) };
    FtpConnection.prototype._authenticated = function() { return !!this.username };
    FtpConnection.prototype._closeDataConnections = function() { if (this.dataSocket) { this._closeSocket(this.dataSocket, true);
            this.dataSocket = null } if (this.pasv) { this.pasv.close();
            this.pasv = null } };
    FtpConnection.prototype._createPassiveServer = function() { var self = this; return net.createServer(function(psocket) { self._logIf(LOG_INFO, "Passive data event: connect"); if (self.secure) { self._logIf(LOG_INFO, "Upgrading passive connection to TLS");
                starttls.starttlsServer(psocket, self.server.options.tlsOptions, function(err, cleartext) { if (err) { self._logIf(LOG_ERROR, "Error upgrading passive connection to TLS:" + util.inspect(err));
                        self._closeSocket(psocket, true);
                        self.dataConfigured = false } else if (!cleartext.authorized) { if (self.server.options.allowUnauthorizedTls) { self._logIf(LOG_INFO, "Allowing unauthorized passive connection (allowUnauthorizedTls is on)");
                            switchToSecure() } else { self._logIf(LOG_INFO, "Closing unauthorized passive connection (allowUnauthorizedTls is off)");
                            self._closeSocket(self.socket, true);
                            self.dataConfigured = false } } else { switchToSecure() }

                    function switchToSecure() { self._logIf(LOG_INFO, "Secure passive connection started");
                        self.dataSocket = cleartext;
                        setupPassiveListener() } }) } else { self.dataSocket = psocket;
                setupPassiveListener() }

            function setupPassiveListener() { if (self.dataListener) { self.dataListener.emit("ready") } else { self._logIf(LOG_WARN, "Passive connection initiated, but no data listener") }
                self.dataSocket.on("close", allOver("close"));
                self.dataSocket.on("end", allOver("end"));

                function allOver(ename) { return function(err) { self._logIf(err ? LOG_ERROR : LOG_DEBUG, "Passive data event: " + ename + (err ? " due to error" : ""));
                        self.dataSocket = null } }
                self.dataSocket.on("error", function(err) { self._logIf(LOG_ERROR, "Passive data event: error: " + err);
                    self.dataSocket = null;
                    self.dataConfigured = false }) } }) };
    FtpConnection.prototype._whenDataReady = function(callback) { var self = this; if (self.dataListener) { if (self.dataSocket) { self._logIf(LOG_DEBUG, "A data connection exists");
                callback(self.dataSocket) } else { self._logIf(LOG_DEBUG, "Currently no data connection; expecting client to connect to pasv server shortly...");
                self.dataListener.once("ready", function() { self._logIf(LOG_DEBUG, "...client has connected now");
                    callback(self.dataSocket) }) } } else { if (self.dataSocket) { self._logIf(LOG_DEBUG, "Using existing non-passive dataSocket");
                callback(self.dataSocket) } else { self._initiateData(function(sock) { callback(sock) }) } } };
    FtpConnection.prototype._initiateData = function(callback) { var self = this; if (self.dataSocket) { return callback(self.dataSocket) } var sock = net.connect(self.dataPort, self.dataHost || self.socket.remoteAddress);
        sock.on("connect", function() { self.dataSocket = sock;
            callback(sock) });
        sock.on("end", allOver);
        sock.on("close", allOver);

        function allOver(err) { self.dataSocket = null;
            self._logIf(err ? LOG_ERROR : LOG_DEBUG, "Non-passive data connection ended" + (err ? "due to error: " + util.inspect(err) : "")) }
        sock.on("error", function(err) { self._closeSocket(sock, true);
            self._logIf(LOG_ERROR, "Data connection error: " + util.inspect(err));
            self.dataSocket = null;
            self.dataConfigured = false }) };
    FtpConnection.prototype._onError = function(err) { this._logIf(LOG_ERROR, "Client connection error: " + util.inspect(err));
        this._closeSocket(this.socket, true) };
    FtpConnection.prototype._onEnd = function() { this._logIf(LOG_DEBUG, "Client connection ended") };
    FtpConnection.prototype._onClose = function(hadError) { if (this.dataSocket) { this._closeSocket(this.dataSocket, hadError);
            this.dataSocket = null } if (this.socket) { this._closeSocket(this.socket, hadError);
            this.socket = null } if (this.pasv) { this.pasv.close();
            this.pasv = null }
        this._logIf(LOG_INFO, "Client connection closed") }; var DOES_NOT_REQUIRE_AUTH = {};
    ["AUTH", "FEAT", "NOOP", "PASS", "PBSZ", "PROT", "QUIT", "TYPE", "SYST", "USER"].forEach(function(c) { DOES_NOT_REQUIRE_AUTH[c] = true }); var REQUIRES_CONFIGURED_DATA = {};
    ["LIST", "NLST", "RETR", "STOR"].forEach(function(c) { REQUIRES_CONFIGURED_DATA[c] = true });
    FtpConnection.prototype._onData = function(data) { var self = this; if (self.hasQuit) { return }
        data = data.toString("utf-8").trim();
        self._logIf(LOG_TRACE, "<< " + data);
        self._logIf(LOG_INFO, "FTP command: " + data.replace(/^PASS [\s\S]*$/i, "PASS ***")); var command; var commandArg; var index = data.indexOf(" "); if (index !== -1) { var parts = data.split(" ");
            command = parts.shift().toUpperCase();
            commandArg = parts.join(" ").trim() } else { command = data.toUpperCase();
            commandArg = "" } var m = "_command_" + command; if (self[m]) { if (self.allowedCommands != null && self.allowedCommands[command] !== true) { self.respond("502 " + command + " not implemented.") } else if (DOES_NOT_REQUIRE_AUTH[command]) { self[m](commandArg, command) } else { if (!self.secure && self.server.options.tlsOnly) { self.respond("522 Protection level not sufficient; send AUTH TLS") } else if (self._authenticated()) { checkData() } else { self.respond("530 Not logged in.") } }

            function checkData() { if (REQUIRES_CONFIGURED_DATA[command] && !self.dataConfigured) { self.respond("425 Data connection not configured; send PASV or PORT"); return }
                self[m](commandArg, command) } } else { self.respond("502 Command not implemented.") }
        self.previousCommand = command };
    FtpConnection.prototype._command_ACCT = function() { this.respond("202 Command not implemented, superfluous at this site."); return this };
    FtpConnection.prototype._command_ALLO = function() { this.respond("202 Command not implemented, superfluous at this site."); return this };
    FtpConnection.prototype._command_AUTH = function(commandArg) { var self = this; if (!self.server.options.tlsOptions || commandArg !== "TLS") { return self.respond("502 Command not implemented") }
        self.respond("234 Honored", function() { self._logIf(LOG_INFO, "Establishing secure connection...");
            starttls.starttlsServer(self.socket, self.server.options.tlsOptions, function(err, cleartext) { if (err) { self._logIf(LOG_ERROR, "Error upgrading connection to TLS: " + util.inspect(err));
                    self._closeSocket(self.socket, true) } else if (!cleartext.authorized) { self._logIf(LOG_INFO, "Secure socket not authorized: " + util.inspect(cleartext.authorizationError)); if (self.server.options.allowUnauthorizedTls) { self._logIf(LOG_INFO, "Allowing unauthorized connection (allowUnauthorizedTls is on)");
                        switchToSecure() } else { self._logIf(LOG_INFO, "Closing unauthorized connection (allowUnauthorizedTls is off)");
                        self._closeSocket(self.socket, true) } } else { switchToSecure() }

                function switchToSecure() { self._logIf(LOG_INFO, "Secure connection started");
                    self.socket = cleartext;
                    self.socket.on("data", function(data) { self._onData(data) });
                    self.secure = true } }) }) };
    FtpConnection.prototype._command_CDUP = function() { var pathServer = pathModule.dirname(this.cwd); var pathEscaped = pathEscape(pathServer);
        this.cwd = pathServer;
        this.respond('250 Directory changed to "' + pathEscaped + '"'); return this };
    FtpConnection.prototype._command_CWD = function(pathRequest) { var pathServer = withCwd(this.cwd, pathRequest); var pathFs = pathModule.join(this.root, pathServer); var pathEscaped = pathEscape(pathServer);
        this.fs.stat(pathFs, function(err, stats) { if (err) { this._logIf(LOG_ERROR, "CWD " + pathRequest + ": " + err);
                this.respond("550 Directory not found.") } else if (!stats.isDirectory()) { this._logIf(LOG_WARN, "Attempt to CWD to non-directory");
                this.respond("550 Not a directory") } else { this.cwd = pathServer;
                this.respond('250 CWD successful. "' + pathEscaped + '" is current directory') } }.bind(this)); return this };
    FtpConnection.prototype._command_DELE = function(commandArg) { var self = this; var filename = withCwd(self.cwd, commandArg);
        self.fs.unlink(pathModule.join(self.root, filename), function(err) { if (err) { self._logIf(LOG_ERROR, "Error deleting file: " + filename + ", " + err);
                self.respond("550 Permission denied") } else { self.respond("250 File deleted") } }) };
    FtpConnection.prototype._command_FEAT = function() { this.respond("211-Features\r\n" + " SIZE\r\n" + " UTF8\r\n" + " MDTM\r\n" + (!this.server.options.tlsOptions ? "" : " AUTH TLS\r\n" + " PBSZ\r\n" + " UTF8\r\n" + " PROT\r\n") + "211 end") };
    FtpConnection.prototype._command_OPTS = function(commandArg) { if (commandArg.toUpperCase() === "UTF8 ON") { this.respond("200 OK") } else { this.respond("451 Not supported") } };
    FtpConnection.prototype._command_MDTM = function(file) { file = withCwd(this.cwd, file);
        file = pathModule.join(this.root, file);
        this.fs.stat(file, function(err, stats) { if (err) { this.respond("550 File unavailable") } else { this.respond("213 " + dateformat(stats.mtime, "yyyymmddhhMMss")) } }.bind(this)); return this };
    FtpConnection.prototype._command_LIST = function(commandArg) { this._LIST(commandArg, true, "LIST") };
    FtpConnection.prototype._command_NLST = function(commandArg) { this._LIST(commandArg, false, "NLST") };
    FtpConnection.prototype._command_STAT = function(commandArg) { if (commandArg) { this._LIST(commandArg, true, "STAT") } else { this.respond("211 FTP Server Status OK") } };
    FtpConnection.prototype._LIST = function(commandArg, detailed, cmd) { var self = this; var dirname = stripOptions(commandArg); var dir = withCwd(self.cwd, dirname);
        glob.setMaxStatsAtOnce(self.server.options.maxStatsAtOnce);
        glob.glob(pathModule.join(self.root, dir), self.fs, function(err, files) { if (err) { self._logIf(LOG_ERROR, "Error sending file list, reading directory: " + err);
                self.respond("550 Not a directory"); return } if (self.server.options.hideDotFiles) { files = files.filter(function(file) { if (file.name && file.name[0] !== ".") { return true } }) }
            self._logIf(LOG_INFO, "Directory has " + files.length + " files"); if (files.length === 0) { return self._listFiles([], detailed, cmd) } var fileInfos; if (!detailed) { fileInfos = files; return finished() }
            fileInfos = []; var CONC = self.server.options.maxStatsAtOnce; var j = 0; for (var i = 0; i < files.length && i < CONC; ++i) { handleFile(i) }
            j = --i;

            function handleFile(ii) { if (i >= files.length) { return i === files.length + j ? finished() : null }
                self.server.getUsernameFromUid(files[ii].stats.uid, function(e1, uname) { self.server.getGroupFromGid(files[ii].stats.gid, function(e2, gname) { if (e1 || e2) { self._logIf(LOG_WARN, "Error getting user/group name for file: " + util.inspect(e1 || e2));
                            fileInfos.push({ file: files[ii], uname: null, gname: null }) } else { fileInfos.push({ file: files[ii], uname: uname, gname: gname }) }
                        handleFile(++i) }) }) }

            function finished() { if (!self.server.options.dontSortFilenames) { if (self.server.options.filenameSortMap !== false) { var sm = self.server.options.filenameSortMap || function(x) { return x.toUpperCase() }; for (var i = 0; i < fileInfos.length; ++i) { fileInfos[i]._s = sm(detailed ? fileInfos[i].file.name : fileInfos[i].name) } } var sf = self.server.options.filenameSortFunc || function(x, y) { return x.localeCompare(y) };
                    fileInfos = fileInfos.sort(function(x, y) { if (self.server.options.filenameSortMap !== false) { return sf(x._s, y._s) } else if (detailed) { return sf(x.file.name, y.file.name) } else { return sf(x.name, y.name) } }) }
                self._listFiles(fileInfos, detailed, cmd) } }, self.server.options.noWildcards) };

    function leftPad(text, width) { var out = ""; for (var j = text.length; j < width; j++) { out += " " }
        out += text; return out }
    FtpConnection.prototype._listFiles = function(fileInfos, detailed, cmd) { var self = this; var m = "150 Here comes the directory listing"; var BEGIN_MSGS = { LIST: m, NLST: m, STAT: "213-Status follows" };
        m = "226 Transfer OK"; var END_MSGS = { LIST: m, NLST: m, STAT: "213 End of status" };
        self.respond(BEGIN_MSGS[cmd], function() { if (cmd === "STAT") { whenReady(self.socket) } else { self._whenDataReady(whenReady) }

            function whenReady(listconn) { if (fileInfos.length === 0) { return success() }

                function success(err) { if (err) { self.respond("550 Error listing files") } else { self.respond(END_MSGS[cmd]) } if (cmd !== "STAT") { self._closeSocket(listconn) } }
                self._logIf(LOG_DEBUG, "Sending file list"); for (var i = 0; i < fileInfos.length; ++i) { var fileInfo = fileInfos[i]; var line = ""; var file; if (!detailed) { file = fileInfo;
                        line += file.name + "\r\n" } else { file = fileInfo.file; var s = file.stats; var allModes = new StatMode({ mode: s.mode }).toString(); var rwxModes = allModes.substr(1, 9);
                        line += (s.isDirectory() ? "d" : "-") + rwxModes;
                        line += " 1 " + (fileInfo.uname || "ftp") + " " + (fileInfo.gname === null ? "ftp" : fileInfo.gname) + " ";
                        line += leftPad(s.size.toString(), 12) + " "; var d = new Date(s.mtime);
                        line += leftPad(dateformat(d, "mmm dd HH:MM"), 12) + " ";
                        line += file.name;
                        line += "\r\n" }
                    self._writeText(listconn, line, i === fileInfos.length - 1 ? success : undefined) } } }) };
    FtpConnection.prototype._command_MKD = function(pathRequest) { var pathServer = withCwd(this.cwd, pathRequest); var pathEscaped = pathEscape(pathServer); var pathFs = pathModule.join(this.root, pathServer);
        this.fs.mkdir(pathFs, 493, function(err) { if (err) { this._logIf(LOG_ERROR, "MKD " + pathRequest + ": " + err);
                this.respond('550 "' + pathEscaped + '" directory NOT created') } else { this.respond('257 "' + pathEscaped + '" directory created') } }.bind(this)); return this };
    FtpConnection.prototype._command_NOOP = function() { this.respond("200 OK"); return this };
    FtpConnection.prototype._command_PORT = function(x, y) { this._PORT(x, y) };
    FtpConnection.prototype._command_EPRT = function(x, y) { this._PORT(x, y) };
    FtpConnection.prototype._PORT = function(commandArg, command) { var self = this; var m;
        self.dataConfigured = false; if (command === "PORT") { m = commandArg.match(/^([0-9]{1,3}),([0-9]{1,3}),([0-9]{1,3}),([0-9]{1,3}),([0-9]{1,3}),([0-9]{1,3})$/); if (!m) { self.respond("501 Bad argument to PORT"); return } var host = m[1] + "." + m[2] + "." + m[3] + "." + m[4]; var port = (parseInt(m[5], 10) << 8) + parseInt(m[6], 10); if (isNaN(port)) { throw new Error("Impossible NaN in FtpConnection.prototype._PORT") } } else { if (commandArg.length >= 3 && commandArg.charAt(0) === "|" && commandArg.charAt(2) === "|" && commandArg.charAt(1) === "2") { self.respond("522 Server cannot handle IPv6 EPRT commands, use (1)"); return }
            m = commandArg.match(/^\|1\|([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})\|([0-9]{1,5})/); if (!m) { self.respond("501 Bad Argument to EPRT"); return } var r = parseInt(m[2], 10); if (isNaN(r)) { throw new Error("Impossible NaN in FtpConnection.prototype._PORT (2)") } if (r > 65535 || r <= 0) { self.respond("501 Bad argument to EPRT (invalid port number)"); return }
            host = m[1];
            port = r }
        self.dataConfigured = true;
        self.dataHost = host;
        self.dataPort = port;
        self._logIf(LOG_DEBUG, "self.dataHost, self.dataPort set to " + self.dataHost + ":" + self.dataPort);
        self.respond("200 OK") };
    FtpConnection.prototype._command_PASV = function(x, y) { this._PASV(x, y) };
    FtpConnection.prototype._command_EPSV = function(x, y) { this._PASV(x, y) };
    FtpConnection.prototype._PASV = function(commandArg, command) { var self = this;
        self.dataConfigured = false; if (command === "EPSV" && commandArg && commandArg !== "1") { self.respond("202 Not supported"); return } if (self.dataSocket) { self._closeSocket(self.dataSocket, true) } if (self.dataListener) { self._logIf(LOG_DEBUG, "Telling client that they can connect now");
            self._writePASVReady(command) } else { self._logIf(LOG_DEBUG, "Setting up listener for passive connections");
            self._setupNewPASV(commandArg, command) }
        self.dataConfigured = true };
    FtpConnection.prototype._writePASVReady = function(command) { var self = this; var a = self.pasv.address(); var host = self.server.host; var port = a.port; if (command === "PASV") { var i1 = port / 256 | 0; var i2 = port % 256;
            self.respond("227 Entering Passive Mode (" + host.split(".").join(",") + "," + i1 + "," + i2 + ")") } else { self.respond("229 Entering Extended Passive Mode (|||" + port + "|)") } };
    FtpConnection.prototype._setupNewPASV = function(commandArg, command) { var self = this; var pasv = self._createPassiveServer(); var portRangeErrorHandler;

        function normalErrorHandler(e) { self._logIf(LOG_WARN, "Error with passive data listener: " + util.inspect(e));
            self.respond("421 Server was unable to open passive connection listener");
            self.dataConfigured = false;
            self.dataListener = null;
            self.dataSocket = null;
            self.pasv = null } if (self.server.options.pasvPortRangeStart != null && self.server.options.pasvPortRangeEnd != null) { var i = self.server.options.pasvPortRangeStart;
            pasv.listen(i);
            portRangeErrorHandler = function(e) { if (e.code === "EADDRINUSE" && i < self.server.options.pasvPortRangeEnd) { pasv.listen(++i) } else { self._logIf(LOG_DEBUG, "Passing on error from portRangeErrorHandler to normalErrorHandler:" + JSON.stringify(e));
                    normalErrorHandler(e) } };
            pasv.on("error", portRangeErrorHandler) } else { pasv.listen(0);
            pasv.on("error", normalErrorHandler) }
        pasv.on("listening", function() { self.pasv = pasv; if (portRangeErrorHandler) { pasv.removeListener("error", portRangeErrorHandler);
                pasv.addListener("error", normalErrorHandler) }
            self._logIf(LOG_DEBUG, "Passive data connection beginning to listen"); var port = pasv.address().port;
            self.dataListener = new PassiveListener;
            self._logIf(LOG_DEBUG, "Passive data connection listening on port " + port);
            self._writePASVReady(command) });
        pasv.on("close", function() { self.pasv = null;
            self.dataListener = null;
            self._logIf(LOG_DEBUG, "Passive data listener closed") }) };
    FtpConnection.prototype._command_PBSZ = function(commandArg) { var self = this; if (!self.server.options.tlsOptions) { return self.respond("202 Not supported") } if (!self.secure) { self.respond("503 Secure connection not established") } else if (parseInt(commandArg, 10) !== 0) { self.pbszReceived = true;
            self.respond("200 buffer too big, PBSZ=0") } else { self.pbszReceived = true;
            self.respond("200 OK") } };
    FtpConnection.prototype._command_PROT = function(commandArg) { var self = this; if (!self.server.options.tlsOptions) { return self.respond("202 Not supported") } if (!self.pbszReceived) { self.respond("503 No PBSZ command received") } else if (commandArg === "S" || commandArg === "E" || commandArg === "C") { self.respond("536 Not supported") } else if (commandArg === "P") { self.respond("200 OK") } else { self.respond("504 Not recognized") } };
    FtpConnection.prototype._command_PWD = function(commandArg) { var pathEscaped = pathEscape(this.cwd); if (commandArg === "") { this.respond('257 "' + pathEscaped + '" is current directory') } else { this.respond("501 Syntax error in parameters or arguments.") } return this };
    FtpConnection.prototype._command_QUIT = function() { var self = this;
        self.hasQuit = true;
        self.respond("221 Goodbye", function(err) { if (err) { self._logIf(LOG_ERROR, "Error writing 'Goodbye' message following QUIT") }
            self._closeSocket(self.socket, true);
            self._closeDataConnections() }) };
    FtpConnection.prototype._command_RETR = function(commandArg) { var filename = pathModule.join(this.root, withCwd(this.cwd, commandArg)); if (this.server.options.useReadFile) { this._RETR_usingReadFile(commandArg, filename) } else { this._RETR_usingCreateReadStream(commandArg, filename) } };
    FtpConnection.prototype._RETR_usingCreateReadStream = function(commandArg, filename) { var self = this; var startTime = new Date;
        self.emit("file:retr", "open", { user: self.username, file: filename, sTime: startTime });

        function afterOk(callback) { self.respond("150 Opening " + self.mode.toUpperCase() + " mode data connection", callback) }
        self.fs.open(filename, "r", function(err, fd) { if (err) { self.emit("file:retr", "error", { user: self.username, file: filename, filesize: 0, sTime: startTime, eTime: new Date, duration: new Date - startTime, errorState: true, error: err }); if (err.code === "ENOENT") { self.respond("550 Not Found") } else { self.respond("550 Not Accessible");
                    self._logIf(LOG_ERROR, "Error at read of '" + filename + "' other than ENOENT " + err) } } else { afterOk(function() { self._whenDataReady(function(pasvconn) { var readLength = 0; var now = new Date; var rs = self.fs.createReadStream(null, { fd: fd });
                        rs.pause();
                        rs.once("error", function(err) { self.emit("file:retr", "close", { user: self.username, file: filename, filesize: 0, sTime: startTime, eTime: now, duration: now - startTime, errorState: true, error: err }) });
                        rs.on("data", function(buffer) { readLength += buffer.length });
                        rs.on("end", function() { var now = new Date;
                            self.emit("file:retr", "close", { user: self.username, file: filename, filesize: 0, sTime: startTime, eTime: now, duration: now - startTime, errorState: false });
                            self.respond("226 Closing data connection, sent " + readLength + " bytes") });
                        rs.pipe(pasvconn);
                        rs.resume() }) }) } }) };
    FtpConnection.prototype._RETR_usingReadFile = function(commandArg, filename) { var self = this; var startTime = new Date;
        self.emit("file:retr", "open", { user: self.username, file: filename, sTime: startTime });

        function afterOk(callback) { self.respond("150 Opening " + self.mode.toUpperCase() + " mode data connection", callback) }
        self.fs.readFile(filename, function(err, contents) { if (err) { self.emit("file:retr", "error", { user: self.username, file: filename, filesize: 0, sTime: startTime, eTime: new Date, duration: new Date - startTime, errorState: true, error: err }); if (err.code === "ENOENT") { self.respond("550 Not Found") } else { self.respond("550 Not Accessible");
                    self._logIf(LOG_ERROR, "Error at read of '" + filename + "' other than ENOENT " + err) } } else { afterOk(function() { self._whenDataReady(function(pasvconn) { contents = { filename: filename, data: contents };
                        self.emit("file:retr:contents", contents);
                        contents = contents.data;
                        pasvconn.write(contents); var contentLength = contents.length;
                        self.respond("226 Closing data connection, sent " + contentLength + " bytes");
                        self.emit("file:retr", "close", { user: self.username, file: filename, filesize: contentLength, sTime: startTime, eTime: new Date, duration: new Date - startTime, errorState: false });
                        self._closeSocket(pasvconn) }) }) } }) };
    FtpConnection.prototype._command_RMD = function(pathRequest) { var pathServer = withCwd(this.cwd, pathRequest); var pathFs = pathModule.join(this.root, pathServer);
        this.fs.rmdir(pathFs, function(err) { if (err) { this._logIf(LOG_ERROR, "RMD " + pathRequest + ": " + err);
                this.respond("550 Delete operation failed") } else { this.respond('250 "' + pathServer + '" directory removed') } }.bind(this)); return this };
    FtpConnection.prototype._command_RNFR = function(commandArg) { var self = this;
        self.filefrom = withCwd(self.cwd, commandArg);
        self._logIf(LOG_DEBUG, "Rename from " + self.filefrom);
        self.respond("350 Ready for destination name") };
    FtpConnection.prototype._command_RNTO = function(commandArg) { var self = this; var fileto = withCwd(self.cwd, commandArg);
        self.fs.rename(pathModule.join(self.root, self.filefrom), pathModule.join(self.root, fileto), function(err) { if (err) { self._logIf(LOG_ERROR, "Error renaming file from " + self.filefrom + " to " + fileto);
                self.respond("550 Rename failed" + (err.code === "ENOENT" ? "; file does not exist" : "")) } else { self.respond("250 File renamed successfully") } }) };
    FtpConnection.prototype._command_SIZE = function(commandArg) { var self = this; var filename = withCwd(self.cwd, commandArg);
        self.fs.stat(pathModule.join(self.root, filename), function(err, s) { if (err) { self._logIf(LOG_ERROR, "Error getting size of file '" + filename + "' ");
                self.respond("450 Failed to get size of file"); return }
            self.respond("213 " + s.size + "") }) };
    FtpConnection.prototype._command_TYPE = function(commandArg) { if (commandArg === "I" || commandArg === "A") { this.respond("200 OK") } else { this.respond("202 Not supported") } };
    FtpConnection.prototype._command_SYST = function() { this.respond("215 UNIX Type: I") };
    FtpConnection.prototype._command_STOR = function(commandArg) { var filename = withCwd(this.cwd, commandArg); if (this.server.options.useWriteFile) { this._STOR_usingWriteFile(filename) } else { this._STOR_usingCreateWriteStream(filename) } };
    FtpConnection.prototype._STOR_usingCreateWriteStream = function(filename, initialBuffers) { var self = this; var wStreamFlags = { flags: "w", mode: 420 }; var storeStream = self.fs.createWriteStream(pathModule.join(self.root, filename), wStreamFlags); var notErr = true; var startTime = new Date; var uploadSize = 0; if (initialBuffers) { initialBuffers.forEach(function(b) { storeStream.write(b) }) }
        self._whenDataReady(handleUpload);
        storeStream.on("open", function() { self._logIf(LOG_DEBUG, "File opened/created: " + filename);
            self._logIf(LOG_DEBUG, "Told client ok to send file data");
            self.emit("file:stor", "open", { user: self.username, file: filename, time: startTime });
            self.respond("150 Ok to send data") });
        storeStream.on("error", function() { self.emit("file:stor", "error", { user: self.username, file: filename, filesize: uploadSize, sTime: startTime, eTime: new Date, duration: new Date - startTime, errorState: !notErr });
            storeStream.end();
            notErr = false; if (self.dataSocket) { self._closeSocket(self.dataSocket, true) }
            self.respond("426 Connection closed; transfer aborted") });
        storeStream.on("finish", function() { self.emit("file:stor", "close", { user: self.username, file: filename, filesize: uploadSize, sTime: startTime, eTime: new Date, duration: new Date - startTime, errorState: !notErr });
            notErr ? self.respond("226 Closing data connection") : true; if (self.dataSocket) { self._closeSocket(self.dataSocket) } });

        function handleUpload(dataSocket) { var isPaused = false;
            dataSocket.on("data", function(buff) { var result = storeStream.write(buff); if (result === false) { dataSocket.pause();
                    isPaused = true;
                    storeStream.once("drain", function() { dataSocket.resume();
                        isPaused = false }) } });
            dataSocket.once("error", function() { notErr = false;
                storeStream.end() });
            dataSocket.once("finish", function() { if (isPaused) { storeStream.once("drain", function() { storeStream.end() }) } else { storeStream.end() } }) } };
    FtpConnection.prototype._STOR_usingWriteFile = function(filename) { var self = this; var erroredOut = false; var slurpBuf = new Buffer(1024); var totalBytes = 0; var startTime = new Date;
        self.emit("file:stor", "open", { user: self.username, file: filename, time: startTime });
        self.respond("150 Ok to send data", function() { self._whenDataReady(handleUpload) });

        function handleUpload() { self.dataSocket.on("data", dataHandler);
            self.dataSocket.once("close", closeHandler);
            self.dataSocket.once("error", errorHandler) }

        function dataHandler(buf) { if (self.server.options.uploadMaxSlurpSize != null && totalBytes + buf.length > self.server.options.uploadMaxSlurpSize) { if (!self.fs.createWriteStream) { if (self.dataSocket) { self._closeSocket(self.dataSocket, true) }
                    self.respond("552 Requested file action aborted; file too big"); return }
                self._logIf(LOG_WARN, "uploadMaxSlurpSize exceeded; falling back to createWriteStream");
                self._STOR_usingCreateWriteStream(filename, [slurpBuf.slice(0, totalBytes), buf]);
                self.dataSocket.removeListener("data", dataHandler);
                self.dataSocket.removeListener("error", errorHandler);
                self.dataSocket.removeListener("close", closeHandler) } else { if (totalBytes + buf.length > slurpBuf.length) { var newLength = slurpBuf.length * 2; if (newLength < totalBytes + buf.length) { newLength = totalBytes + buf.length } var newSlurpBuf = new Buffer(newLength);
                    slurpBuf.copy(newSlurpBuf, 0, 0, totalBytes);
                    slurpBuf = newSlurpBuf }
                buf.copy(slurpBuf, totalBytes, 0, buf.length);
                totalBytes += buf.length } }

        function closeHandler() { if (erroredOut) { return } var contents = { filename: filename, data: slurpBuf.slice(0, totalBytes) };
            self.emit("file:stor:contents", contents);
            self.fs.writeFile(pathModule.join(self.root, filename), contents.data, function(err) { self.emit("file:stor", "close", { user: self.username, file: filename, filesize: totalBytes, sTime: startTime, eTime: new Date, duration: new Date - startTime, errorState: err ? true : false }); if (err) { erroredOut = true;
                    self._logIf(LOG_ERROR, "Error writing file. " + err); if (self.dataSocket) { self._closeSocket(self.dataSocket, true) }
                    self.respond("426 Connection closed; transfer aborted"); return }
                self.respond("226 Closing data connection"); if (self.dataSocket) { self._closeSocket(self.dataSocket) } }) }

        function errorHandler() { erroredOut = true } };
    FtpConnection.prototype._command_USER = function(username) { var self = this; if (self.server.options.tlsOnly && !self.secure) { self.respond("530 This server does not permit login over " + "a non-secure connection; " + "connect using FTP-SSL with explicit AUTH TLS") } else { self.emit("command:user", username, function success() { self.respond("331 User name okay, need password.") }, function failure() { self.respond("530 Not logged in.") }) } return this };
    FtpConnection.prototype._command_PASS = function(password) { var self = this; if (self.previousCommand !== "USER") { self.respond("503 Bad sequence of commands.") } else { self.emit("command:pass", password, function success(username, userFsModule) {
                function panic(error, method) { self._logIf(LOG_ERROR, method + " signaled error " + util.inspect(error));
                    self.respond("421 Service not available, closing control connection.", function() { self._closeSocket(self.socket, true) }) }

                function setCwd(cwd) {
                    function setRoot(root) { self.root = root;
                        self.respond("230 User logged in, proceed.") }
                    self.cwd = cwd; if (self.server.getRoot.length <= 1) { setRoot(self.server.getRoot(self)) } else { self.server.getRoot(self, function(err, root) { if (err) { panic(err, "getRoot") } else { setRoot(root) } }) } }
                self.username = username;
                self.fs = userFsModule || fsModule; if (self.server.getInitialCwd.length <= 1) { setCwd(withCwd(self.server.getInitialCwd(self))) } else { self.server.getInitialCwd(self, function(err, cwd) { if (err) { panic(err, "getInitialCwd") } else { setCwd(withCwd(cwd)) } }) } }, function failure() { self.respond("530 Not logged in.");
                self.username = null }) } return this };
    FtpConnection.prototype._closeSocket = function(socket, shouldDestroy) { if (shouldDestroy || this.server.options.destroySockets) { if (!socket.destroyed) { socket.destroy() } } else { if (socket.writable) { socket.end() } } };
    exports.FtpServer = FtpServer }, function(module, exports) { module.exports = require("net") }, function(module, exports) { module.exports = require("util") }, function(module, exports) { module.exports = require("events") }, function(module, exports) { module.exports = require("fs") }, function(module, exports) { module.exports = Mode; var S_IFMT = 61440; var S_IFIFO = 4096; var S_IFCHR = 8192; var S_IFDIR = 16384; var S_IFBLK = 24576; var S_IFREG = 32768; var S_IFLNK = 40960; var S_IFSOCK = 49152; var S_IFWHT = 57344; var S_ISUID = 2048; var S_ISGID = 1024; var S_ISVTX = 512; var S_IRUSR = 256; var S_IWUSR = 128; var S_IXUSR = 64; var S_IRGRP = 32; var S_IWGRP = 16; var S_IXGRP = 8; var S_IROTH = 4; var S_IWOTH = 2; var S_IXOTH = 1;

    function Mode(stat) { if (!(this instanceof Mode)) return new Mode(stat); if (!stat) throw new TypeError('must pass in a "stat" object'); if ("number" != typeof stat.mode) stat.mode = 0;
        this.stat = stat;
        this.owner = new Owner(stat);
        this.group = new Group(stat);
        this.others = new Others(stat) }
    Mode.prototype.valueOf = function() { return this.stat.mode };
    Mode.prototype.toString = function() { var str = []; if (this.isDirectory()) { str.push("d") } else if (this.isFile()) { str.push("-") } else if (this.isBlockDevice()) { str.push("b") } else if (this.isCharacterDevice()) { str.push("c") } else if (this.isSymbolicLink()) { str.push("l") } else if (this.isFIFO()) { str.push("p") } else if (this.isSocket()) { str.push("s") } else { throw new TypeError('unexpected "file type"') }
        str.push(this.owner.read ? "r" : "-");
        str.push(this.owner.write ? "w" : "-"); if (this.setuid) { str.push(this.owner.execute ? "s" : "S") } else { str.push(this.owner.execute ? "x" : "-") }
        str.push(this.group.read ? "r" : "-");
        str.push(this.group.write ? "w" : "-"); if (this.setgid) { str.push(this.group.execute ? "s" : "S") } else { str.push(this.group.execute ? "x" : "-") }
        str.push(this.others.read ? "r" : "-");
        str.push(this.others.write ? "w" : "-"); if (this.sticky) { str.push(this.others.execute ? "t" : "T") } else { str.push(this.others.execute ? "x" : "-") } return str.join("") };
    Mode.prototype.toOctal = function() { var octal = this.stat.mode & 4095; return ("0000" + octal.toString(8)).slice(-4) };
    Mode.prototype._checkModeProperty = function(property, set) { var mode = this.stat.mode; if (set) { this.stat.mode = (mode | S_IFMT) & property | mode & ~S_IFMT } return (mode & S_IFMT) === property };
    Mode.prototype.isDirectory = function(v) { return this._checkModeProperty(S_IFDIR, v) };
    Mode.prototype.isFile = function(v) { return this._checkModeProperty(S_IFREG, v) };
    Mode.prototype.isBlockDevice = function(v) { return this._checkModeProperty(S_IFBLK, v) };
    Mode.prototype.isCharacterDevice = function(v) { return this._checkModeProperty(S_IFCHR, v) };
    Mode.prototype.isSymbolicLink = function(v) { return this._checkModeProperty(S_IFLNK, v) };
    Mode.prototype.isFIFO = function(v) { return this._checkModeProperty(S_IFIFO, v) };
    Mode.prototype.isSocket = function(v) { return this._checkModeProperty(S_IFSOCK, v) };
    _define(Mode.prototype, "setuid", function() { return Boolean(this.stat.mode & S_ISUID) }, function(v) { if (v) { this.stat.mode |= S_ISUID } else { this.stat.mode &= ~S_ISUID } });
    _define(Mode.prototype, "setgid", function() { return Boolean(this.stat.mode & S_ISGID) }, function(v) { if (v) { this.stat.mode |= S_ISGID } else { this.stat.mode &= ~S_ISGID } });
    _define(Mode.prototype, "sticky", function() { return Boolean(this.stat.mode & S_ISVTX) }, function(v) { if (v) { this.stat.mode |= S_ISVTX } else { this.stat.mode &= ~S_ISVTX } });

    function Owner(stat) { _define(this, "read", function() { return Boolean(stat.mode & S_IRUSR) }, function(v) { if (v) { stat.mode |= S_IRUSR } else { stat.mode &= ~S_IRUSR } });
        _define(this, "write", function() { return Boolean(stat.mode & S_IWUSR) }, function(v) { if (v) { stat.mode |= S_IWUSR } else { stat.mode &= ~S_IWUSR } });
        _define(this, "execute", function() { return Boolean(stat.mode & S_IXUSR) }, function(v) { if (v) { stat.mode |= S_IXUSR } else { stat.mode &= ~S_IXUSR } }) }

    function Group(stat) { _define(this, "read", function() { return Boolean(stat.mode & S_IRGRP) }, function(v) { if (v) { stat.mode |= S_IRGRP } else { stat.mode &= ~S_IRGRP } });
        _define(this, "write", function() { return Boolean(stat.mode & S_IWGRP) }, function(v) { if (v) { stat.mode |= S_IWGRP } else { stat.mode &= ~S_IWGRP } });
        _define(this, "execute", function() { return Boolean(stat.mode & S_IXGRP) }, function(v) { if (v) { stat.mode |= S_IXGRP } else { stat.mode &= ~S_IXGRP } }) }

    function Others(stat) { _define(this, "read", function() { return Boolean(stat.mode & S_IROTH) }, function(v) { if (v) { stat.mode |= S_IROTH } else { stat.mode &= ~S_IROTH } });
        _define(this, "write", function() { return Boolean(stat.mode & S_IWOTH) }, function(v) { if (v) { stat.mode |= S_IWOTH } else { stat.mode &= ~S_IWOTH } });
        _define(this, "execute", function() { return Boolean(stat.mode & S_IXOTH) }, function(v) { if (v) { stat.mode |= S_IXOTH } else { stat.mode &= ~S_IXOTH } }) }

    function _define(obj, name, get, set) { Object.defineProperty(obj, name, { enumerable: true, configurable: true, get: get, set: set }) } }, function(module, exports, __webpack_require__) { var dateFormat = function() { var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|"[^"]*"|'[^']*'/g,
            timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
            timezoneClip = /[^-+\dA-Z]/g,
            pad = function(val, len) { val = String(val);
                len = len || 2; while (val.length < len) val = "0" + val; return val },
            getWeek = function(date) { var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                targetThursday.setDate(targetThursday.getDate() - (targetThursday.getDay() + 6) % 7 + 3); var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);
                firstThursday.setDate(firstThursday.getDate() - (firstThursday.getDay() + 6) % 7 + 3); var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
                targetThursday.setHours(targetThursday.getHours() - ds); var weekDiff = (targetThursday - firstThursday) / (864e5 * 7); return 1 + weekDiff },
            getDayOfWeek = function(date) { var dow = date.getDay(); if (dow === 0) dow = 7; return dow }; return function(date, mask, utc, gmt) { var dF = dateFormat; if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) { mask = date;
                date = undefined }
            date = date || new Date; if (!(date instanceof Date)) { date = new Date(date) } if (isNaN(date)) { throw TypeError("Invalid date") }
            mask = String(dF.masks[mask] || mask || dF.masks["default"]); var maskSlice = mask.slice(0, 4); if (maskSlice == "UTC:" || maskSlice == "GMT:") { mask = mask.slice(4);
                utc = true; if (maskSlice == "GMT:") { gmt = true } } var _ = utc ? "getUTC" : "get",
                d = date[_ + "Date"](),
                D = date[_ + "Day"](),
                m = date[_ + "Month"](),
                y = date[_ + "FullYear"](),
                H = date[_ + "Hours"](),
                M = date[_ + "Minutes"](),
                s = date[_ + "Seconds"](),
                L = date[_ + "Milliseconds"](),
                o = utc ? 0 : date.getTimezoneOffset(),
                W = getWeek(date),
                N = getDayOfWeek(date),
                flags = { d: d, dd: pad(d), ddd: dF.i18n.dayNames[D], dddd: dF.i18n.dayNames[D + 7], m: m + 1, mm: pad(m + 1), mmm: dF.i18n.monthNames[m], mmmm: dF.i18n.monthNames[m + 12], yy: String(y).slice(2), yyyy: y, h: H % 12 || 12, hh: pad(H % 12 || 12), H: H, HH: pad(H), M: M, MM: pad(M), s: s, ss: pad(s), l: pad(L, 3), L: pad(L > 99 ? Math.round(L / 10) : L), t: H < 12 ? "a" : "p", tt: H < 12 ? "am" : "pm", T: H < 12 ? "A" : "P", TT: H < 12 ? "AM" : "PM", Z: gmt ? "GMT" : utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""), o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4), S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10], W: W, N: N }; return mask.replace(token, function($0) { return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1) }) } }();
    dateFormat.masks = { default: "ddd mmm dd yyyy HH:MM:ss", shortDate: "m/d/yy", mediumDate: "mmm d, yyyy", longDate: "mmmm d, yyyy", fullDate: "dddd, mmmm d, yyyy", shortTime: "h:MM TT", mediumTime: "h:MM:ss TT", longTime: "h:MM:ss TT Z", isoDate: "yyyy-mm-dd", isoTime: "HH:MM:ss", isoDateTime: "yyyy-mm-dd'T'HH:MM:ss", isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'", expiresHeaderFormat: "ddd, dd mmm yyyy HH:MM:ss Z" };
    dateFormat.i18n = { dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }; if (true) { module.exports = dateFormat } }, function(module, exports, __webpack_require__) { var PathModule = __webpack_require__(0); var CONC = 5;

    function setMaxStatsAtOnce(n) { CONC = n }

    function statList(fsm, list, callback) { if (list.length === 0) { return callback(null, []) } var stats = []; var total = list.length; for (var i = 0; i < CONC; ++i) { handleFile() } var erroredOut = false;

        function handleFile() { if (erroredOut) { return } if (list.length === 0) { if (stats.length === total) { finished() } return } var path = list.shift();
            fsm.stat(path, function(err, st) { if (err) { erroredOut = true;
                    callback(err) } else { stats.push({ name: PathModule.basename(path), stats: st });
                    handleFile() } }) }

        function finished() { callback(null, stats) } }

    function matchPattern(pattern, string) { var pi = 0; var si = 0; for (; si < string.length && pi < pattern.length; ++si) { var c = string.charAt(si); var pc = pattern.charAt(pi); if (pc === "*") { if (pi + 1 === pattern.length) {} else if (pattern.charAt(pi + 1) === "*") {--si;++pi } else if (pattern.charAt(pi + 1) === "?") {++pi } else if (si < string.length - 1 && pattern.charAt(pi + 1) === string.charAt(si)) { pi += 2 } } else if (pc === "?") {++pi } else if (pc === c) {++pi } else { return false } } return (pi === pattern.length || pi === pattern.length - 1 && pattern.charAt(pi) === "*") && si === string.length }

    function glob(path, fsm, callback, noWildcards) { var w; for (w = 0; !noWildcards && w < path.length && path.charAt(w) !== "*" && path.charAt(w) !== "?"; ++w) {} if (w === path.length) { fsm.readdir(path, function(err, contents) { if (err) { if (err.code === "ENOTDIR") { statList(fsm, [path], function(err, list) { if (err) { return callback(err) } if (list.length !== 1) { throw new Error("Internal error in glob.js") }
                            callback(null, list) }) } else if (err.code === "ENOENT") { callback(null, []) } else { callback(err) } } else { statList(fsm, contents.map(function(p) { return PathModule.join(path, p) }), function(err, list) { if (err) { callback(err) } else { callback(null, list) } }) } }); return } else { var i; for (i = w; i < path.length; ++i) { if (path.charAt(i) === "/") { return callback(null, []) } } var base = ""; var pattern; for (i = w; i >= 0; --i) { if (path.charAt(i) === "/") { base = path.substr(0, i + 1); break } }
            pattern = path.substr(i === 0 ? 0 : i + 1); for (i = 0; i < pattern.length && pattern.charAt(i) === "/"; ++i) {} if (i > 0) { pattern = pattern.substr(i) } for (i = base.length - 1; i > 0 && base.charAt(i) === "/"; --i) {} if (i !== base.length - 1) { base = base.substr(0, i + 1) }
            readTheDir(false);

            function readTheDir(listingSingleDir) { fsm.readdir(base, function(err, contents) { if (err) { if (err.code === "ENOTDIR" || err.code === "ENOENT") { callback(null, []) } else { callback(err) } } else { var matches; if (!listingSingleDir) { matches = contents.filter(function(n) { return matchPattern(pattern, n) }) } else { matches = contents } if (!listingSingleDir && matches.length === 1) { var dir = PathModule.join(base, matches[0]);
                            fsm.stat(dir, function(err, st) { if (err) { return callback(err) } if (!st.isDirectory()) { doTheNormalThing() } else { base = dir;
                                    readTheDir(true) } }) } else { doTheNormalThing() }

                        function doTheNormalThing() { statList(fsm, matches.map(function(p) { return PathModule.join(base, p) }), function(err, list) { if (err) { callback(err) } else { callback(null, list) } }) } } }) } } }
    exports.glob = glob;
    exports.matchPattern = matchPattern;
    exports.setMaxStatsAtOnce = setMaxStatsAtOnce }, function(module, exports, __webpack_require__) { var tls = __webpack_require__(10); var crypto = __webpack_require__(11); var RECOMMENDED_CIPHERS = "ECDHE-RSA-AES256-SHA:AES256-SHA:RC4-SHA:RC4:HIGH:!MD5:!aNULL:!EDH:!AESGCM";

    function starttlsServer(socket, options, callback) { return starttls(socket, options, callback, true) }

    function starttlsClient(socket, options, callback) { return starttls(socket, options, callback, false) }

    function starttls(socket, options, callback, isServer) { var sslcontext; var opts = {};
        Object.keys(options).forEach(function(key) { opts[key] = options[key] }); if (!opts.ciphers) { opts.ciphers = RECOMMENDED_CIPHERS }
        socket.removeAllListeners("data"); if (tls.createSecureContext) { sslcontext = tls.createSecureContext(opts) } else { sslcontext = crypto.createCredentials(opts) } var pair = tls.createSecurePair(sslcontext, isServer); var cleartext = pipe(pair, socket); var erroredOut = false;
        pair.on("secure", function() { if (erroredOut) { pair.end(); return } var verifyError = (pair._ssl || pair.ssl).verifyError(); if (verifyError) { cleartext.authorized = false;
                cleartext.authorizationError = verifyError } else { cleartext.authorized = true }
            callback(null, cleartext) });
        pair.once("error", function(err) { if (!erroredOut) { erroredOut = true;
                callback(err) } });
        cleartext._controlReleased = true;
        pair }

    function forwardEvents(events, emitterSource, emitterDestination) { var map = []; for (var i = 0, len = events.length; i < len; i++) { var name = events[i]; var handler = forwardEvent.bind(emitterDestination, name);
            map.push(name);
            emitterSource.on(name, handler) } return map }

    function forwardEvent() { this.emit.apply(this, arguments) }

    function removeEvents(map, emitterSource) { for (var i = 0, len = map.length; i < len; i++) { emitterSource.removeAllListeners(map[i]) } }

    function pipe(pair, socket) { pair.encrypted.pipe(socket);
        socket.pipe(pair.encrypted);
        pair.fd = socket.fd; var cleartext = pair.cleartext;
        cleartext.socket = socket;
        cleartext.encrypted = pair.encrypted;
        cleartext.authorized = false;

        function onerror(e) { if (cleartext._controlReleased) { cleartext.emit("error", e) } } var map = forwardEvents(["timeout", "end", "close", "drain", "error"], socket, cleartext);

        function onclose() { socket.removeListener("error", onerror);
            socket.removeListener("close", onclose);
            removeEvents(map, socket) }
        socket.on("error", onerror);
        socket.on("close", onclose); return cleartext }
    exports.starttlsServer = starttlsServer;
    exports.starttlsClient = starttlsClient;
    exports.RECOMMENDED_CIPHERS = RECOMMENDED_CIPHERS }, function(module, exports) { module.exports = require("tls") }, function(module, exports) { module.exports = require("crypto") }]);